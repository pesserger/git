git 学习第一步，需要先init
commit after
change 
使用 git log 可以查看历次修改 然后使用git reset --hard 1094a 回退到某次修改，然后工作区的文件就是当时那个时间点提交的时候的状态
那么如果修改没有提交的话，一旦回退，你的修改就丢失了，所以在使用这个回退功能之前需要全部提交，不然就白做了
使用 add .把当前目录下面的所有修改都提交，不知道子目录里面的会不会提交
使用Git reset --hard head 可以查看当前是在那个修改状态
可以看到当使用add . 的时候会把所有修改都添加进去的，add之后在使用Git status 查看可以看到变颜色了，并且列出了要提交的文件
当使用Git add之后如果没有及时提交，再次修改了，那么提交的时候提交的还是上次add的内容
可以使用Git reflog 查看每次提交的head值，从而可以实现回退穿梭

就像上面说的，add之后的修改是提交不了的，所以提交的肯定不是当前文件，git管理的是修改，而不是文件，根据修改记录生成文件，从而节约存储空间
现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。
你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。
为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：
https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374829472990293f16b45df14f35b94b3e8a026220c5000

使用git checkout -- first.txt 可以从工作区里面检出，把当前工作区内容替换掉
不过可以看到当使用add之后在使用checkout，工作区文件就恢复不了
使用 git reset head first.txt 就看把暂存区里面的修改删除从而可以checkout了