git 学习第一步，需要先init
commit after
change 
使用 git log 可以查看历次修改 然后使用git reset --hard 1094a 回退到某次修改，然后工作区的文件就是当时那个时间点提交的时候的状态
那么如果修改没有提交的话，一旦回退，你的修改就丢失了，所以在使用这个回退功能之前需要全部提交，不然就白做了
使用 add .把当前目录下面的所有修改都提交，不知道子目录里面的会不会提交
使用Git reset --hard head 可以查看当前是在那个修改状态
可以看到当使用add . 的时候会把所有修改都添加进去的，add之后在使用Git status 查看可以看到变颜色了，并且列出了要提交的文件
当使用Git add之后如果没有及时提交，再次修改了，那么提交的时候提交的还是上次add的内容
可以使用Git reflog 查看每次提交的head值，从而可以实现回退穿梭

就像上面说的，add之后的修改是提交不了的，所以提交的肯定不是当前文件，git管理的是修改，而不是文件，根据修改记录生成文件，从而节约存储空间
现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。
你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。
为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：
https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374829472990293f16b45df14f35b94b3e8a026220c5000

使用git checkout -- first.txt 可以从工作区里面检出，把当前工作区内容替换掉
不过可以看到当使用add之后在使用checkout，工作区文件就恢复不了
使用 git reset head first.txt 就看把暂存区里面的修改删除从而可以checkout了


本地文件删除了，如果不需要可以把他们从版本库里面删除掉，使用Git rm 命令，如果本地误删了可以使用git checkout -- file恢复过来
其实这里面看checkout就是检出呀，不过还可以切换分支

svn是集中式的，git是分布式的理解
git 是本地都有一个仓库，默认提交本地
svn 只能提交到服务器，但是svn本地也有历史记录文件.svn，这个文件里面有整个项目的历史记录，已经日志等，但是既然是集中式的了，为什么还需要这些
把pristine删除之后，发现提交不了，初步猜测，为了减轻服务器压力，svn设计的时候在本地有整个缓存，本地的每一步操作先和本地的历史比较，有没有更改
等，或者查看历史修改日志等，这些数据不用每次都从服务器获取，所以在checkout的时候把所有数据都给客户端，这些数据就是缓存，本地只是用这些数据
不修改，只有服务器修改这些数据，这样，就很大程度上减轻服务器压力了，这么说svn也是把整个项目都下下来的和git一样的，只是管理方式上不同
一个只能提交到服务器，一个是提交本地仓库，没有网络也可以，这么说git更省事一些，修改什么东西了不用再搭建svn服务器就可以保存变动记录
另外就是本地都有整个数据，但是作用不同，svn只不过是为了减轻服务器压力，git是当成仓库了
其实原理都差不多
svn 也是需要add的，然后提交。svn需要判断每个文件的修改情况，这个也是本地数据的作用吧
svn也不是简单的把数据提交到服务器或者仓库这么简单。
其实就像网站和客户端一样，为了减轻服务器压力都会有一些缓存，但是所缓存数据的作用却不同，比如网站利用浏览器韩村一些静态文件
app却可以缓存更原始的数据。但是具体的数据却不是看到的，svn服务器存储的也是原始数据信息，并不是文件
我们检出时候的文件是利用服务器数据生成的。
完全可以根据网站和app类比svn和git，网站需要网络，app没有网络也可以使用

但是这里面有个问题，怎么忽略一些文件的更改
使用ssh-keygen -t rsa -C "pesserger@163.com"，生成公匙私匙，保存的位置默认就可以了，然后在github.com里面添加，使用的时候
就可以验证我和github是同一个账户了



